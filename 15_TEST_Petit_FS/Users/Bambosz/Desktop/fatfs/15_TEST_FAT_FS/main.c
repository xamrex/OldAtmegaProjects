/*----------------------------------------------------------------------*/
/* FAT file system sample project for FatFs            (C)ChaN, 2010    */
/*----------------------------------------------------------------------*/



#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <string.h>
#include "FatFS/ff.h"
#include "FatFS/diskio.h"
#include "rtc.h"
#include "LCD/lcd44780.h"
#include <avr/delay.h>
#include <stdlib.h>
unsigned char PROGMEM tablica[5]="avzq";
//char tablica[]="1111111111111111111111111111111111222222222222222222222222222333333333333333333333333333333332222222222211111111111111111222222222222222222222222222333333333333333333333333333333332222222222211111111111111111222222222222222222222222222333333333333333333333333333333332222222222211111111111111111111111111111111111111112222222222222222222222222223333333333333333333333333333333322222222222111111111111111112222222222222222222222222223333333333333333333333333333333333333333322222222222211111122222222222222222222222222233333333333333331111112222222222222222222222222223333333333333333";
char nul[1]={0};
volatile uint16_t czas;

DWORD acc_size;				/* Work register for fs command */
WORD acc_files, acc_dirs;
FILINFO Finfo;
#if _USE_LFN
char Lfname[_MAX_LFN+1];
#endif


char Line[128];				/* Console input buffer */

FATFS Fatfs[_VOLUMES];		/* File system object for each logical drive */
BYTE Buff[256];			/* Working buffer */

volatile WORD Timer;		/* 100Hz increment timer */



#if _MULTI_PARTITION != 0
const PARTITION Drives[] = { {0,0}, {0,1} };
#endif

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/


ISR(TIMER2_COMP_vect)
{
	Timer++;			/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}

/*---------------------------------------------------------*/
/* co 10ms timer do liczenia czasu                         */
/*---------------------------------------------------------*/
ISR(TIMER0_COMP_vect)
{

czas++;

}

/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support a real time clock.          */
/* This is not required in read-only configuration.        */


DWORD get_fattime ()
{
	RTC rtc;


	/* Get local time */
	//rtc_gettime(&rtc);
	rtc.year = 2010;
	rtc.month = 10;
	rtc.mday = 21;
	rtc.hour = 17;
	rtc.min = 45;
	rtc.sec = 0;


	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
}


/*--------------------------------------------------------------------------*/
/* Monitor                                                                  */


//static
//void put_dump (const BYTE *buff, DWORD ofs, BYTE cnt)
//{
//	BYTE i;
//
//
//	xprintf(PSTR("%08lX "), ofs);
//
//	for(i = 0; i < cnt; i++)
//		xprintf(PSTR(" %02X"), buff[i]);
//
//	xputc(' ');
//	for(i = 0; i < cnt; i++)
//		xputc((buff[i] >= ' ' && buff[i] <= '~') ? buff[i] : '.');
//
//	xputc('\n');
//}
//
//
//static
//void get_line (char *buff, int len)
//{
//	BYTE c;
//	int i = 0;
//
//
//	for (;;) {
//		c = uart_get();
//		if (c == '\r') break;
//		if ((c == '\b') && i) {
//			i--;
//			uart_put(c);
//			continue;
//		}
//		if (c >= ' ' && i < len - 1) {	/* Visible chars */
//			buff[i++] = c;
//			xputc(c);
//		}
//	}
//	buff[i] = 0;
//	uart_put('\n');
//}
//

//static
//FRESULT scan_files (
//	char* path		/* Pointer to the working buffer with start path */
//)
//{
//	DIR dirs;
//	FRESULT res;
//	int i;
//	char *fn;
//
//	res = f_opendir(&dirs, path);
//	if (res == FR_OK) {
//		i = strlen(path);
//		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
//			if (_FS_RPATH && Finfo.fname[0] == '.') continue;
//#if _USE_LFN
//			fn = *Finfo.lfname ? Finfo.lfname : Finfo.fname;
//#else
//			fn = Finfo.fname;
//#endif
//			if (Finfo.fattrib & AM_DIR) {
//				acc_dirs++;
//				*(path+i) = '/'; strcpy(path+i+1, fn);
//				res = scan_files(path);
//				*(path+i) = '\0';
//				if (res != FR_OK) break;
//			} else {
////				xprintf(PSTR("%s/%s\n"), path, fn);
//				acc_files++;
//				acc_size += Finfo.fsize;
//			}
//		}
//	}
//
//	return res;
//}








static
void IoInit ()
{
	PORTA = 0b11111111;	// Port A

	PORTB = 0b10110000; // Port B
	DDRB  = 0b11000000;

	PORTC = 0b11111111;	// Port C

	PORTD = 0b11111111; // Port D



	//uart_init();		// Initialize UART driver

/*
	OCR1A = 51;			// Timer1: LCD bias generator (OC1B)
	OCR1B = 51;
	TCCR1A = 0b00010000;
	TCCR1B = 0b00001010;
*/

	//atmega32
	/* Timer2 – inicjalizacja przerwania co 10ms */
	TCCR2 = (1<<WGM21);		// tryb pracy CTC
	TCCR2 = (1<<CS22)|(1<<CS21)|(1<<CS20);	// preskaler = 1024
	OCR2 = 108;		// przerwanie porównania co 10ms (100Hz)
	TIMSK |= (1<<OCIE2);	// Odblokowanie przerwania CompareMatch


	sei();
}

void timer0(void){
	//Timer0 do liczenia :)

	TCCR0 |= (1<<WGM01); //tryb ctc
	TCCR0 |= (1<<CS02)|(1<<CS00); //prescaler 1024
	OCR0 = 107;// co 10 ms przerwanie
	TIMSK |= (1<<OCIE0); //zezwolenie na comprae match

}

/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
{


	//char tablica[20]="0\n1\n2\n3\n4\n5\n6\n7\n8\n9";
//char tablica[4]="adam";


IoInit();
lcd_init();
#define SCK PB7
#define MOSI PB5
#define CS PB4

	DDRB |= (1<<CS)|(1<<MOSI)|(1<<SCK)|(1<<CS);
	PORTB |= (1<<CS);
	SPCR |= (1<<SPE)|(1<<MSTR);
	SPSR |= (1<<SPI2X); //szybkosc 2x

////////////////////////////////////////////////////////////////////////////
FATFS fs;         /* Work area (file system object) for logical drives */
FIL fsrc;      /* file objects */
UINT br, bw;

lcd_str("bufadd");

_delay_ms(1000);
char buforek1[2];
char buforek2[7];
char buforek3[2];
uint8_t wynik1,wynik2,wynik3;
 /* Register work area for each volume (Always succeeds regardless of disk status) */


disk_initialize(0);
f_mount(0, &fs);

 /* Open source file on the drive 1 */
wynik1=f_open(&fsrc, "nowy5.txt", FA_WRITE|FA_CREATE_ALWAYS);


czas++;

//wynik2=f_read(&fsrc, buforek, 17, &br);

//wynik3=f_write(&fsrc, bufor, sizeof(bufor), &bw);

timer0(); //wlaczamy timerek

//uint16_t ilosc=0;
//for (ilosc=0;ilosc<52429;ilosc++){
f_write(&fsrc, pgm_read_byte(&tablica), sizeof(tablica), &bw);
//}

wynik3=f_write(&fsrc, nul, 1, &bw);
//f_write(&fsrc, tablica, sizeof(tablica), &bw);

//tu wylaczmy timerek
itoa(czas,buforek2,10);


itoa(wynik1,buforek1,10);
//itoa(wynik2,buforek2,10);
itoa(wynik3,buforek3,10);
 /* Close open files */
 f_close(&fsrc); // Trzeba zamknac

 /* Unregister work area prior to discard it */
 f_mount(0, NULL);

lcd_locate(1,0);
 lcd_str("kod ble:");
lcd_str(buforek1);
lcd_str(buforek3);
lcd_str("-");
lcd_str(buforek2);


return 0;
}

